// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IPoolManager} from "../interfaces/IPoolManager.sol";
import {IHooks} from "../interfaces/IPoolManager.sol";
import {BalanceDelta} from "../libraries/BalanceDelta.sol";

/// @notice Interface for Groth16 verifier contracts generated by snarkjs
/// @dev This matches the standard Groth16 verifier interface from snarkjs
interface IGroth16Verifier {
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[] memory publicSignals
    ) external view returns (bool);
}

/// @title ProductionComplianceHook
/// @notice Production-ready Uniswap v4 hook with Groth16 zk-SNARK proof verification
/// @dev This hook enforces compliance using real Groth16 proofs generated from compliance.circom
contract ProductionComplianceHook is IHooks {
    /// @notice The pool manager contract
    IPoolManager public immutable poolManager;

    /// @notice The Groth16 verifier contract
    IGroth16Verifier public immutable groth16Verifier;

    /// @notice Mapping from user address to their compliance data hash
    mapping(address => bytes32) public userComplianceHashes;

    /// @notice Mapping from proof hash to whether it's been used (replay protection)
    mapping(bytes32 => bool) public usedProofs;

    /// @notice Mapping from user address to last proof submission timestamp
    mapping(address => uint256) public lastProofTimestamp;

    /// @notice Admin address
    address public admin;

    /// @notice Whether the hook is enabled
    bool public enabled;

    /// @notice Proof expiration time (default: 30 days)
    uint256 public proofExpiration;

    /// @notice Compliance requirements configuration
    struct ComplianceRequirements {
        bool requireKYC;
        bool requireAgeVerification;
        bool requireLocationCheck;
        bool requireSanctionsCheck;
        uint256 minAge;
        bytes2 allowedCountryCode; // ISO country code (2 bytes)
    }

    ComplianceRequirements public requirements;

    /// @notice Events
    event HookEnabled(bool enabled);
    event RequirementsUpdated(ComplianceRequirements requirements);
    event ProofSubmitted(
        address indexed user,
        bytes32 indexed proofHash,
        bytes32 indexed dataHash,
        uint256 timestamp
    );
    event ProofVerified(address indexed user, bytes32 indexed proofHash, bool isValid);
    event SwapBlocked(address indexed user, string reason);
    event LiquidityBlocked(address indexed user, string reason);

    /// @notice Errors
    error HookNotEnabled();
    error InvalidProof();
    error ProofExpired();
    error ProofAlreadyUsed();
    error UserNotCompliant();
    error InvalidPublicSignals();
    error Unauthorized();
    error InvalidComplianceHash();

    modifier onlyAdmin() {
        if (msg.sender != admin) revert Unauthorized();
        _;
    }

    modifier onlyWhenEnabled() {
        if (!enabled) revert HookNotEnabled();
        _;
    }

    modifier onlyPoolManager() {
        if (msg.sender != address(poolManager)) revert Unauthorized();
        _;
    }

    /// @notice Constructor
    /// @param _poolManager The Uniswap v4 PoolManager contract
    /// @param _groth16Verifier The deployed Groth16 verifier contract address
    /// @param _requirements Compliance requirements configuration
    /// @param _proofExpiration Proof expiration time in seconds (default: 30 days)
    constructor(
        IPoolManager _poolManager,
        IGroth16Verifier _groth16Verifier,
        ComplianceRequirements memory _requirements,
        uint256 _proofExpiration
    ) {
        poolManager = _poolManager;
        groth16Verifier = _groth16Verifier;
        admin = msg.sender;
        enabled = true;
        requirements = _requirements;
        proofExpiration = _proofExpiration > 0 ? _proofExpiration : 30 days;
    }

    /// @notice Submit a Groth16 zk-SNARK proof for compliance verification
    /// @param a Groth16 proof component A (uint256[2])
    /// @param b Groth16 proof component B (uint256[2][2])
    /// @param c Groth16 proof component C (uint256[2])
    /// @param publicSignals Public signals from the proof (must include complianceHash as first element)
    /// @dev The publicSignals array should contain:
    ///      [0] = complianceHash (bytes32 as uint256)
    ///      [1] = isValid (1 if compliant, 0 otherwise)
    function submitProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[] memory publicSignals
    ) external onlyWhenEnabled {
        // Validate public signals length (at least 2: complianceHash and isValid)
        if (publicSignals.length < 2) revert InvalidPublicSignals();

        // Extract compliance hash and validation result from public signals
        bytes32 complianceHash = bytes32(publicSignals[0]);
        uint256 isValid = publicSignals[1];

        // Verify the proof using Groth16 verifier
        bool proofValid = groth16Verifier.verifyProof(a, b, c, publicSignals);
        if (!proofValid) revert InvalidProof();

        // Check that the proof indicates compliance
        if (isValid == 0) revert UserNotCompliant();

        // Generate proof hash for replay protection
        bytes32 proofHash = keccak256(
            abi.encodePacked(a[0], a[1], b[0][0], b[0][1], b[1][0], b[1][1], c[0], c[1], publicSignals)
        );

        // Check for replay attacks
        if (usedProofs[proofHash]) revert ProofAlreadyUsed();

        // Mark proof as used
        usedProofs[proofHash] = true;

        // Store compliance hash for the user
        userComplianceHashes[msg.sender] = complianceHash;
        lastProofTimestamp[msg.sender] = block.timestamp;

        emit ProofSubmitted(msg.sender, proofHash, complianceHash, block.timestamp);
        emit ProofVerified(msg.sender, proofHash, true);
    }

    /// @notice Verify user compliance status
    /// @param user The user address to check
    /// @return isCompliant True if user is compliant
    /// @return complianceHash The user's compliance data hash
    /// @return lastProofTime Timestamp of last proof submission
    function checkCompliance(
        address user
    ) external view returns (bool isCompliant, bytes32 complianceHash, uint256 lastProofTime) {
        complianceHash = userComplianceHashes[user];
        lastProofTime = lastProofTimestamp[user];

        // User is compliant if:
        // 1. They have a valid compliance hash
        // 2. Their proof hasn't expired
        isCompliant = (complianceHash != bytes32(0)) &&
            (lastProofTime > 0) &&
            (block.timestamp <= lastProofTime + proofExpiration);
    }

    /// @notice Internal function to verify compliance before swap/liquidity operations
    /// @param user The user address
    /// @param hookData Additional hook data (can contain proof if needed)
    /// @param action The action being performed ("swap" or "liquidity")
    function _verifyCompliance(address user, bytes calldata hookData, string memory action) internal view {
        // Check if hook is enabled
        if (!enabled) revert HookNotEnabled();

        // Get user's compliance status
        (bool isCompliant, bytes32 complianceHash, uint256 lastProofTime) = this.checkCompliance(user);

        // Check if user has submitted a proof
        if (complianceHash == bytes32(0)) {
            revert UserNotCompliant();
        }

        // Check if proof has expired
        if (lastProofTime == 0 || block.timestamp > lastProofTime + proofExpiration) {
            revert ProofExpired();
        }

        // Verify compliance status
        if (!isCompliant) {
            revert UserNotCompliant();
        }
    }

    /// @notice Uniswap v4 hook: Called before a swap
    /// @param sender The address initiating the swap
    /// @param key The pool key
    /// @param params Swap parameters
    /// @param hookData Additional hook data
    /// @return selector The function selector to indicate hook was called
    function beforeSwap(
        address sender,
        IPoolManager.PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        bytes calldata hookData
    ) external override onlyPoolManager onlyWhenEnabled returns (bytes4) {
        _verifyCompliance(sender, hookData, "swap");
        return this.beforeSwap.selector;
    }

    /// @notice Uniswap v4 hook: Called after a swap
    /// @param sender The address that initiated the swap
    /// @param key The pool key
    /// @param params Swap parameters
    /// @param delta The balance delta from the swap
    /// @param hookData Additional hook data
    /// @return selector The function selector
    function afterSwap(
        address sender,
        IPoolManager.PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        BalanceDelta delta,
        bytes calldata hookData
    ) external override onlyPoolManager returns (bytes4) {
        // No additional checks needed after swap
        return this.afterSwap.selector;
    }

    /// @notice Uniswap v4 hook: Called before adding liquidity
    /// @param sender The address initiating the liquidity addition
    /// @param key The pool key
    /// @param params Modify liquidity parameters
    /// @param hookData Additional hook data
    /// @return selector The function selector to indicate hook was called
    function beforeAddLiquidity(
        address sender,
        IPoolManager.PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata params,
        bytes calldata hookData
    ) external override onlyPoolManager onlyWhenEnabled returns (bytes4) {
        _verifyCompliance(sender, hookData, "liquidity");
        return this.beforeAddLiquidity.selector;
    }

    /// @notice Uniswap v4 hook: Called after adding liquidity
    /// @param sender The address that initiated the liquidity addition
    /// @param key The pool key
    /// @param params Modify liquidity parameters
    /// @param delta The balance delta from the liquidity operation
    /// @param hookData Additional hook data
    /// @return selector The function selector
    function afterAddLiquidity(
        address sender,
        IPoolManager.PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata params,
        BalanceDelta delta,
        bytes calldata hookData
    ) external override onlyPoolManager returns (bytes4) {
        // No additional checks needed after adding liquidity
        return this.afterAddLiquidity.selector;
    }

    /// @notice Admin function to enable/disable the hook
    function setEnabled(bool _enabled) external onlyAdmin {
        enabled = _enabled;
        emit HookEnabled(_enabled);
    }

    /// @notice Admin function to update compliance requirements
    function updateRequirements(ComplianceRequirements memory _requirements) external onlyAdmin {
        requirements = _requirements;
        emit RequirementsUpdated(_requirements);
    }

    /// @notice Admin function to update proof expiration time
    function setProofExpiration(uint256 _proofExpiration) external onlyAdmin {
        proofExpiration = _proofExpiration;
    }

    /// @notice Admin function to manually set user compliance (for testing/emergency)
    /// @dev This bypasses proof verification - use with caution
    function setUserCompliance(
        address user,
        bytes32 complianceHash,
        bool compliant
    ) external onlyAdmin {
        if (compliant) {
            userComplianceHashes[user] = complianceHash;
            lastProofTimestamp[user] = block.timestamp;
        } else {
            delete userComplianceHashes[user];
            delete lastProofTimestamp[user];
        }
    }

    /// @notice Get hook permissions (required by Uniswap v4)
    function getHookPermissions() external pure returns (uint16) {
        // Return permissions for beforeSwap, afterSwap, beforeAddLiquidity, afterAddLiquidity
        return 0x000F; // All four hooks enabled
    }
}

